#+TITLE: Notes from Road to Learn React
* Introduction to React
** Using lists
   We need a key in order to work with JS lists (list -> JSX elem) so React knows when to update the individual nodes.
** ES6
*** Functions
    #+BEGIN_SRC js
    // this a standard function:
    const sum = function(a, b) {
      return a + b
    }

    // es6 arrow function
    const sum = (a, b) => {
      return a + b
    }

    // without braces, the expr is the return
    const sum = (a, b) =>
      a + b

    // don't need parenthesis if we have one input variable
    const abs = a =>
      (a < 0)? a : -a
    #+END_SRC

*** Objects Definitions
    #+BEGIN_SRC js
    /*
     * Object in ES5 go by
     * var obj = {
     *   property: value
     * }
     */
    
    // in ES6 we can shorthand initializers like this
    const obj = {
      list: list // notice the property and value keys are the same
    }

    const obj = {
      list
    }

    // in ES6 we can shorthand functions like this
    const obj = {
      prop: function(a) {
        return a
      }
    }

    const obj = {
      prop(a) {
        return a
      }
    }

    // Can also use computed property names
    const name = 'charlie'
    const obj = {
      [name]: 'a baller' // evaluates to 'charlie' : 'a baller'
    }
    #+END_SRC

*** Object destructuring
    #+BEGIN_SRC js
    // remember in python you could do
    // (hi, python_rocks) = list_or_tuple # ?

    // you can do that with es6 now
    {hi, jsRocksToo} = obj

    // useful in functional stateless components
    const Component = (props) =>
      <div> {props.xD} </div>

    const Component = ({xD}) =>
      <div> {xd} </div>
    #+END_SRC
* Basics in React
** Button onClick
   #+BEGIN_SRC js
   // need to bind this for class functions
   constructor(props) {
     // ...
     this.onDismiss = this.onDismiss.bind(this)
   }

   // ...
   <button onClick={() => this.onDismiss(site.objectID)}
           type='button'>
     dismiss
   </button>
   // notice the react prop onClick, which takes in a function to handle an
   //  synthetic event.  We don't use it here (we just pass in objectID, but...

   // our button onClick handler, which just prunes our list.
   // NOTE: pattern: every function that sets state needs to be in the React class
   //  and binded (to use this)
   onDismiss(id) {
     let updated = this.state.list.filter(site =>
       id !== site.objectID)

     this.setState({
       list: updated
     })
   }  // remember to bind in constructor to use this
   #+END_SRC
** Client search bar
   #+BEGIN_SRC js
   // first we need to add a form
   // <App> ...
   <form>
     <input type='text'
            onChange={this.onSearchChange}
     />
   </form>
   // notice that we have the react onChange prop to pass in a function handler
   //  the function takes in an syntheic event

   // the onChange handler, which takes in a synthetic event
   onSearchChange(event) {
    this.setState({ searchTerm: event.target.value })
   }

   // be sure to to update our state to include searchTerm and bind this   
   constructor(props) {
    super(props)
    this.state = {
      list,
      searchTerm : ''
    }
    this.onDismiss = this.onDismiss.bind(this)
    this.onSearchChange = this.onSearchChange.bind(this)
   }

   // to 'search' we apply a filter to our list like this:
   // list.filter(isSearched).map(ourComponents)
   {this.state.list.filter(isSearched(this.state.searchTerm)).map(site =>
     <div key={site.objectID}>
        <h3><a href={site.url}>{site.title}</a></h3>
         <p>
           Author: {site.author}
         </p>
         {/*more data components here*/}
      </div>

   // our filter needs a filter to filter with.  We could have an internal function (bind this for state)
   // or use a higher order function (we do this :) )
   const isSearched = (searchTerm) =>
     (site) => {
       return !searchTerm.trim() || 
         site.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
         site.author.toLowerCase().includes(searchTerm.toLowerCase())
   }
   // note the initial !searchTerm is to detect an empty string, so we match everything
   #+END_SRC
** Controlled components
   Certain =<html>= components have their own state, like =<form>= elements (=<input>=, =<textarea>=, =<select>=).  We want React's state to be the single source of truth, so we add an =value= prop to the =<input>= like so.

   #+BEGIN_SRC js
   <form>
    <input
      type='text'
      value={value}
      onChange={onChange}
    />
   </form>
   #+END_SRC
** Composable Components
   I know this.
** Reusable Components
   CLOSED: [2017-10-12 Thu 20:23]
   I know this.
